limit_req_zone 127.0.0.1 zone=one:10m rate=1r/m;
server
{
    listen 8084;
    access_log /usr/local/openresty/nginx/logs/access.log;
    error_log  /usr/local/openresty/nginx/logs/error.log;
    error_log  /usr/local/openresty/nginx/logs/error.log  notice;
    error_log  /usr/local/openresty/nginx/logs/error.log  info;
    set $TESTE 'asda';
    location /
    {
        proxy_pass http://10.27.160.124:8103;
    }

}

#SSL test
server
{
    default_type text/html;
    listen 8081;
    ssl on;
    
    location /
    {
        content_by_lua 
        '
            ngx.say("hello")
        ';
    }
}
server
{
    keepalive_timeout 65;
    listen 8082;
    location /test
    {
        default_type text/html;
        content_by_lua
        '
            local shell = require("resty.shell")

            -- define a table to hold arguments with the following elements:
            --
            -- timeout: timeout for the socket connection
            --
            -- data: STDIN to send to sockproc
            --
            -- socket: either a table containg the elements host and port for tcp connections,
            -- or a string defining a unix socket
            local args = {
                socket = "unix:/tmp/nginx.sock",
            }

            local status, out, err = shell.execute("./usr/local/openresty/nginx/src/che/start_che.sh start blas 8094", args)
            ngx.header.content_type = "text/plain"
            ngx.say("Hello from:" .. out)
            
        ';
    }
}

#MYSQLs

server
{
    listen 8086;
    ssl on;
    set $PORT "";
    location ~* /(\w+)$
    {
        default_type text/html;
        rds_json_root rows;
        set $USER $1;

        rewrite_by_lua '
            
            local shell = require("resty.shell")
            local args = 
            {
                socket = "unix:/tmp/nginx.sock",
            }

            local cjson = require "cjson"    
            local mysql = require "resty.mysql"
            local db, err = mysql:new()
            local user_id = ngx.var.USER -- Grabs the user name from the URL
            local che_port = 8090 --Default port for che

            if not db then
                ngx.say("failed to instantiate mysql: ", err)
                return
            end

            db:set_timeout(1000) -- 1 sec

            local ok, err, errcode, sqlstate = db:connect{
               host = "127.0.0.1",
               port = 3306,
               database = "nginx",
               user = "root",
               password = "root",
               max_packet_size = 1024 * 1024 
            }

            if not ok then
                ngx.log(ngx.ERR,"failed to connect: ", err, ": ", errcode, " ", sqlstate)
                return
            end

            --ngx.say("connected to mysql.")

            --Checks if the table is empty

            res, err, errcode, sqlstate = db:query("show table status")

            nRows = tonumber(res[1].Rows)

            --If the table is empty
            if nRows == 0 then
                res, err, errcode, sqlstate = db:query("insert into Containers (Registration_ID) values (\'" ..user_id.. "\')")
                    
               -- ngx.say("Insertion was successfull")

                res, err, errcode, sqlstate = db:query("select Container_Port from Containers where Registration_ID=\'" .. user_id .."\'")

                che_port = res[1].Container_Port

            else

                -- Searches in the database for a row indicating the existence of a container belonging to the user. --   It uses the parameter in the url as a key in the search, matching it with registration_id.

                res, err, errcode, sqlstate = db:query("select * from Containers where Registration_ID=\'" .. user_id .."\'")

                if not res then
                    ngx.log(ng.ERR,"Error on query for container matching the id on the url: ", err, ": ", errcode, ": ", sqlstate, ".")
                    return "Error"
                end

                -- Query result equals to zero, that indicates that a container belonging to the user does not exist
                if #res == 0 then
                    
                    -- A row was found in the table, so users already exist 
                    -- So it does the following:
                    -- 1 - Obtain the biggest port value
                    -- 2 - Increase it by one and store it on the variable che_port
                    -- 3 - Use it as port value for the container belonging to the user attempting to use the service.

                    res, err, errcode, sqlstate = db:query("insert into Containers (Registration_ID) values (\'" ..user_id.. "\')")

                    if not res then
                        ngx.log(ngx.ERR,"Error inserting the new user: ", err, ": ", errcode, ":",sqlstate, ".")
                        return "Error"
                    end

                    res, err, errcode, sqlstate = db:query("select Container_Port from Containers where Registration_ID=\'" .. user_id .."\'")

                    che_port = res[1].Container_Port
                    
                else    
                    che_port = res[1].Container_Port
                end                
            end
            local status, out, err = shell.execute("./usr/local/openresty/nginx/src/che/start_che.sh start "..user_id.." "..che_port, args)
            ngx.var.PORT = che_port;
        ';
        echo_blocking_sleep 600;
        echo "Testee porra";
        proxy_connect_timeout       300;
        proxy_send_timeout          300;
        proxy_read_timeout          300;
        send_timeout                300;
        proxy_pass http://127.0.0.1:$PORT;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
}
server
{
    listen 8120;
    ssl on;
    location /
    {

        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_pass http://127.0.0.1:8106;
    }
}
